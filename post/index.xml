<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Miao&amp;Blog</title>
    <link>https://charliemini.githhub.io/post/</link>
    <description>Recent content in Posts on Miao&amp;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>charlie_cc@foxmail.com (Miao)</managingEditor>
    <webMaster>charlie_cc@foxmail.com (Miao)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Wed, 26 Jun 2019 14:35:31 +0800</lastBuildDate>
    
        <atom:link href="https://charliemini.githhub.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>猫</title>
      <link>https://charliemini.githhub.io/post/%E7%8C%AB/</link>
      <pubDate>Wed, 26 Jun 2019 14:35:31 +0800</pubDate>
      <author>charlie_cc@foxmail.com (Miao)</author>
      <guid>https://charliemini.githhub.io/post/%E7%8C%AB/</guid>
      <description>&lt;p&gt;汤姆&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GO学习笔记</title>
      <link>https://charliemini.githhub.io/post/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 25 Jun 2019 18:53:09 +0800</pubDate>
      <author>charlie_cc@foxmail.com (Miao)</author>
      <guid>https://charliemini.githhub.io/post/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h1 id=&#34;go学习笔记&#34;&gt;GO学习笔记&lt;/h1&gt;

&lt;h2 id=&#34;结构化程序&#34;&gt;结构化程序&lt;/h2&gt;

&lt;p&gt;每个程序都由pkg的概念组成，必须在源代码里非注释的第一行致指明这个文件属于哪一个包,注意包的名字都要用小写字母。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package main&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;p&gt;重定义包名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import fm &amp;quot;fmt&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果导入了一个没有使用的包会报错&lt;/p&gt;

&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;

&lt;p&gt;结构化的类型以nil作为默认值&lt;/p&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;p&gt;用const定义，用于存储不会改变的数据线，只能是布尔型、数字和字符串。&lt;/p&gt;

&lt;p&gt;支持显、隐式类型定义&lt;/p&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;p&gt;用&lt;code&gt;var&lt;/code&gt;关键字声明变量 &lt;code&gt;var identifier type&lt;/code&gt; OR &lt;code&gt;var identifier type = value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当变量被声明后，系统自动赋予它该类型的零型，所有的内存在go中都是经过初始化的。变量命名规则遵循驼峰法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果希望全局变量被外部包使用，则需要将首个单词字母大写&lt;/strong&gt;*。&lt;/p&gt;

&lt;p&gt;在函数体内部初始化声明变量时可以使用简短的语法：&lt;code&gt;a := 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;声明局部变量而不去使用它同样会出现编译错误&lt;/p&gt;

&lt;p&gt;使用等于号进行变量间的相互赋值时，只是引用了同一个地址指针。&lt;/p&gt;

&lt;p&gt;如果想要交换两个文明变量的值，可以使用&lt;code&gt;a,b = b,a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_&lt;/code&gt; 被当作一个只写变量&lt;/p&gt;

&lt;p&gt;全局变量除了可以在全局声明中初始化，也可以在&lt;code&gt;init&lt;/code&gt;函数中初始化,也就是在声明的全局变量，可以经由&lt;code&gt;init&lt;/code&gt; 函数更改赋值并作用于整个程序作用域。&lt;/p&gt;

&lt;h2 id=&#34;基本类型与运算符&#34;&gt;基本类型与运算符&lt;/h2&gt;

&lt;p&gt;GO是强类型语言，只支持显示转换，所以只有类型严格相同时才可以做运算操作。&lt;/p&gt;

&lt;p&gt;不允许不同类型之间的混合使用，但允许和常量之间的混合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	var a int
	var b int 16
	a = 1
	b = a + a // 错误
	b = b + 5 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化字符串：%d用于格式化字符串&lt;/p&gt;

&lt;p&gt;​                           %x，%X用于格式化16进制表示的数字&lt;/p&gt;

&lt;p&gt;​                           %g用于格式化浮点数（%f输出浮点数，%e输出科学计数表示法）&lt;/p&gt;

&lt;p&gt;​                            %0d用于输出定长的整数&lt;/p&gt;

&lt;p&gt;​                           %n.mg用于表示数字n并精确到小数点后m位，g还可以替换为e，f&lt;/p&gt;

&lt;p&gt;在算数运算时溢出并不会产生错误，只会将超出的位数抛弃。对于产出范围的有理数可以使用标准库中的&lt;code&gt;big&lt;/code&gt;包&lt;/p&gt;

&lt;p&gt;为了简化名称和解决名称冲突，可以使用类型别名。&lt;code&gt;type A int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GO字符串中字符为ASCII时占用一个字节，其它字符根据需要占据2-4个字节。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings&lt;/code&gt;包&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;strings.HasPrefix(s, string) bool 判断s是否以string开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.HasSuffix(s, string) bool 判断s是否以string结尾&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Contains(s, string) bool 判断字符串s是否包含string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Index(s, string) int 返回字符串string在s中第一个匹配的索引，返回-1表示不存在&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.LastIndex(s, string) int返回字符串string在s中最后一个匹配的索引，返回-1表示不存在&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于非ASCII编码的ch，建议使用strings,IndexRune定位                            strings.IndexRune(s, ch) int&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Replace(s, old, new, n) string 字符替换，n表示替换前几个字符，n=-1表示全替换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Count(s, string) int 计算string在s中出现的非重叠次数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Repeat(s, count int) string 返回count次重复字符串s的的心字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.ToLower(s) string 转化为小写字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.ToUpper(s) string 转化大写字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.TrimSpace(s, &amp;ldquo;&amp;rdquo;) 剔除字符串s开头结尾指定字符&lt;/p&gt;

&lt;p&gt;strings.TrimLeft()&lt;/p&gt;

&lt;p&gt;strings.TrimRight()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string.Fields(s, sep) 切割字符串，返回slice&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string.Join(sl []string, sep string) string 将字符串数组用字符sep拼接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String.NewReader(str) 用于生成一个reader并读取字符串中的内容，并返回指向该reader的指针。&lt;/p&gt;

&lt;p&gt;Read() —&amp;gt; byte&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;strconv&lt;/code&gt;包&lt;/p&gt;

&lt;p&gt;用于字符串相关的类型转换。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strconv.Atoi(s string) (i int, err error)&lt;/code&gt; 将字符串转换为 int 型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strconv.IntSize&lt;/code&gt; 获取程序运行的操作系统下int所占位数&lt;/p&gt;

&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;

&lt;p&gt;无法得到常量的地址&lt;/p&gt;

&lt;p&gt;对于一个空指针的反向引用是不合法的&lt;/p&gt;

&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;不要同时在if-else结构的两个分支里都使用return语句，会导致程序编译错误。(GO1.1 已修复)&lt;/p&gt;

&lt;p&gt;Runtime.GOOS 是常量，是程序运行的操作系统类型。&lt;/p&gt;

&lt;p&gt;if 可以包含初始化语句&lt;code&gt;if a := 10; a &amp;gt; number&lt;/code&gt; 这种方式定义的变量a只存在于if语句的作用域中。&lt;/p&gt;

&lt;p&gt;switch中，如果在命中case后还希望执行下面的case，可以使用&lt;code&gt;fallthrough&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;Go里的for循环和C一样，但存在一个for-range结构，可以迭代任何一个集合.     &lt;code&gt;for pos,char := range str&lt;/code&gt;  pos为索引位置，char为值。&lt;/p&gt;

&lt;p&gt;For,    switch,     select语句都可以配合标签使用。&lt;/p&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;p&gt;用&lt;code&gt;func&lt;/code&gt;定义函数，函数体用{}括起来&lt;/p&gt;

&lt;p&gt;main函数没有参数，也没有返回类型&lt;/p&gt;

&lt;p&gt;Go不允许进行函数重载，函数可以以声明的方式被使用，不需要函数体。&lt;/p&gt;

&lt;p&gt;返回多个非命名返回值时，需要在函数头事先用（）括起返回类型，尽量不要使用非命名返回值。&lt;/p&gt;

&lt;p&gt;在go中存在变参函数，类似于python中的*args，在传参中使用&lt;code&gt;name ...type&lt;/code&gt;的形式，可以传递多个同类型的参数形式。如果不确定变长参数的类型或者变长参数存在多种类型的时候，可以用默认的空接口&lt;code&gt;interface{}&lt;/code&gt;代替type。&lt;/p&gt;

&lt;p&gt;Go允许自己定义结构类型,其中可以混合多种变量类型.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type struct_name struct{
	part1 int,
	part float,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字defer在函数中被使用的时候，会在程序将要返回时执行，它类似栈，如果有多个defer会从最后面的开始执行。它允许我们进行一些&amp;rdquo;收尾&amp;rdquo;工作，比如关闭文件流，打印，解锁，关闭数据库，实现代码追踪。&lt;/p&gt;

&lt;p&gt;在大量的递归调用中可能会发生栈溢出的问题，也就是栈资源耗尽。&lt;/p&gt;

&lt;p&gt;匿名函数无法单独存在，但可以赋值给一个变量，func 关键字必须紧贴着第一个括号。这类似闭包，闭包可以看作是函数与外部变量的组合体，外部变量和函数一直存在。闭包避免了使用全局变量，将数据与函数紧密结合。&lt;/p&gt;

&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;var identifier [len]type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当数组还未定义时，可以使用make方法定义切片&lt;code&gt;var slice1 []type = make([]type, len)&lt;/code&gt;  简写为&lt;code&gt;slice1 := make([]type, len)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;[]byte&lt;/code&gt;进行切片要使用bytes包，&lt;code&gt;var buffer bytes.Buffer&lt;/code&gt;                       &lt;code&gt;var r *bytes.Buffer = new(bytes.Buffer)&lt;/code&gt; 利用buffer.WriteString(s)的方法拼接内容比使用 &lt;code&gt;+=&lt;/code&gt; 更省内存和cpu。&lt;/p&gt;

&lt;p&gt;遍历数组和切片可以使用 for-range 结构，返回数组索引和value。&lt;/p&gt;

&lt;p&gt;append方法可以实现对切片元素的增加，切片的拼接。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;

&lt;p&gt;map对应的数据结构时字典。&lt;code&gt;var mapname map[keytype]valuetype&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>