<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Miao&amp;Blog on Miao&amp;Blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://charliemini.github.io/</link>
    <language>zh</language>
    
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <updated>Mon, 22 Jul 2019 11:22:58 CST</updated>
    
    <item>
      <title>机器学习算法--随机森林</title>
      <link>https://charliemini.github.io/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</link>
      <pubDate>Mon, 22 Jul 2019 11:22:58 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</guid>
      <description>&lt;h1 id=&#34;机器学习算法-随机&#34;&gt;机器学习算法-随机&lt;/h1&gt;

&lt;h2 id=&#34;随机森林&#34;&gt;随机森林&lt;/h2&gt;

&lt;p&gt;随机森林是监督学习的一种，是基于多个决策树生成的，所以先要理解决策树。&lt;/p&gt;

&lt;h3 id=&#34;决策树的原理&#34;&gt;决策树的原理&lt;/h3&gt;

&lt;p&gt;决策树采用向下递归的方式，以信息熵为度量构造一颗熵值下降最快的树，具有可读性高、分类速度快等特点。&lt;/p&gt;

&lt;p&gt;我们可以简单地将决策树想象为一个节点做True/False判断的二叉树，实际上他并不只是只有二叉。它基于数据形成，从而预测类别或回归情况下的连续值。决策树可分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;离散型：分类决策树，目标变量时离散的，比如性别等分类数据。&lt;/li&gt;
&lt;li&gt;连续型：目标变量时连续的，如工资。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常见的决策树算法有：ID3, C4.5, CART&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ID3&lt;/strong&gt;:  基于信息增益理论选择特征递归地构建决策树。信息增益可以这样理解&amp;ndash;存在一个数据集D,它的熵值（不确定性）为H(D),现在给它一个条件特征A，此时D的条件熵就变成了H(D|A).而信息增益就是就是数据集熵值和条件熵值的差值，Gain(D, A) = H(D) - H(D|A)。如此，可以得出如果信息增益值越大，则划分后的数据自己熵就越低，就更准确，ID3算法每次会挑选信息增益最大特征划分数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;C4.5&lt;/strong&gt;: C4.5对ID3算法做了改进，因为计算信息增益时会偏向取值较多的特征，所以采用信息增益比来进行矫正。GainRatio(D,A) = Gain(D, A)/H(D)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;CART&lt;/strong&gt;: CART算法引入了gini&amp;ndash;基尼不纯度的概念，指的是根据节点中样本的分布对样本分类时，从节点中随机选择样本被分错的概率。在算法运行中，总会计算该节点的基尼不纯度，选择基尼不纯度最小的特征进行切分。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是不管哪种算法，决策树总可能存在过拟合的问题，即此决策树模型能够完美匹配训练集的数据，但是不能准确预测数据。假如我们不限制树的深度，这意味着它将为每一个观察点生成一个叶子节点，对训练集数据达到过分的完美拟合，造成过拟合。如果限制树的深度，则可能造成分类的准确性下降，增加模型的偏差。所以要平衡好决策树是不容易的一件事，所以为了解决这个问题，就产生了用多棵决策树形成随机森林的方案。&lt;/p&gt;

&lt;h3 id=&#34;构造随机森林&#34;&gt;构造随机森林&lt;/h3&gt;

&lt;p&gt;首先了解什么叫做自助抽样法：每一次抽取样本后，将样本返回，在下一次有概率抽到以抽取过的样本。&lt;/p&gt;

&lt;p&gt;上面说过，随机森林由多棵决策树形成，它所要决定的是如何构造这些决策树。对一个数据集D，他有m行数据，n个特征，我们采用自主抽样法每次抽m1(m1&amp;lt;m)行，n1(n1&amp;lt;n)个特征数据构造决策树。在形成随机森林后，考虑每棵树的预测结果给出真正的预测结果。&lt;/p&gt;

&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;

&lt;p&gt;随机森林的优缺点&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;随机森林算法能解决分类与回归两种类型的问题，表现良好，由于是集成学习，方差和偏差都比较低，泛化性能优越；&lt;/li&gt;
&lt;li&gt;随机森林对于高维数据集的处理能力很好，它可以处理成千上万的输入变量，并确定最重要的变量，因此被认为是一个不错的降维方法。此外，该模型能够输出特征的重要性程度，这是一个非常实用的功能。&lt;/li&gt;
&lt;li&gt;可以应对缺失数据；&lt;/li&gt;
&lt;li&gt;当存在分类不平衡的情况时，随机森林能够提供平衡数据集误差的有效方法；&lt;/li&gt;
&lt;li&gt;高度并行化，易于分布式实现&lt;/li&gt;
&lt;li&gt;由于是树模型，不需要归一化即可使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;随机森林在解决回归问题时并没有像它在分类中表现的那么好，这是因为它并不能给出一个连续型的输出。当进行回归时，随机森林不能够作出超越训练集数据范围的预测，这可能导致在对某些还有特定噪声的数据进行建模时出现过度拟合。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于许多统计建模者来说，随机森林给人的感觉像是一个黑盒子——你几乎无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;忽略特征之间的相关性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;xgboost&#34;&gt;xgboost&lt;/h2&gt;

&lt;p&gt;Xgboost 也是一种集成算法，基于一堆CART决策树形成，每棵决策树处理上一棵决策树遗留的“残差”，最终将所有CART预测目标结果相加即可得到最终预测值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监督学习&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;学习率&lt;/strong&gt;：控制着我们基于损失梯度调整神经网络权值的速度。直观来说，学习率越大，机器学习速度越快，但很容易越过最优值，在某一位置反复震荡；学习率过小，则机器学习的速度就变得太慢，可能会得到局部最优解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据处理笔记</title>
      <link>https://charliemini.github.io/post/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 12 Jul 2019 14:21:45 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;数据处理&#34;&gt;数据处理&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;数据分析最主要的是数据，数据是分析的基石和导向，一定要保证数据的可靠性和所要得到的结果之间的关联性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;numpy&#34;&gt;numpy&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ny.reshape(-1, 1)&lt;/code&gt; 改变numpy纬度，-1表示不确定行数，根据列数匹配。&lt;/p&gt;

&lt;p&gt;numpy.corrcoef(x, y)&lt;/p&gt;

&lt;p&gt;返回皮尔森相关系数，类似df.corr() 默认参数的方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df.merge(data, on= columns)&lt;/code&gt; 合并&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df.groupby()&lt;/code&gt; 分组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;np.linspace(start, stop, num)&lt;/code&gt; 返回一个start值为首，end值为尾，共num个值的等差队列&lt;/p&gt;

&lt;h2 id=&#34;sklearn&#34;&gt;sklearn&lt;/h2&gt;

&lt;h3 id=&#34;预处理&#34;&gt;预处理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sklearn.preprocessing.LabelEncoder&lt;/code&gt; 对不连续的数字或字符串数据进行编号&lt;/p&gt;

&lt;h4 id=&#34;缺失值处理&#34;&gt;缺失值处理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;class sklearn.impute.SimpleImputer(missing_values=nan, strategy=’mean’, fill_value=None, verbose=0, copy=True, add_indicator=False)[source]


my_imputer = SimpleImputer()
imputed_X_train = pd.DataFrame(my_imputer.fit_transform(X_train))
imputed_X_valid = pd.DataFrame(my_imputer.transform(X_valid))

# Imputation removed column names; put them back
imputed_X_train.columns = X_train.columns
imputed_X_valid.columns = X_valid.columns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;填补缺失值。&lt;/p&gt;

&lt;h4 id=&#34;处理分类变量&#34;&gt;处理分类变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;编码转换，将分类变量根据某一趋势转换成数值性变量&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;  from sklearn.preprocessing import LabelEncoder
  
  # Make copy to avoid changing original data 
  label_X_train = X_train.copy()
  label_X_valid = X_valid.copy()
  
  # Apply label encoder to each column with categorical data
  label_encoder = LabelEncoder()
  for col in object_cols:
      label_X_train[col] = label_encoder.fit_transform(X_train[col])
      label_X_valid[col] = label_encoder.transform(X_valid[col])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;one-hot编码，根据分类变量创建多列，然后用1或0表示是否。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;  from sklearn.preprocessing import OneHotEncoder
  
  # Apply one-hot encoder to each column with categorical data
  OH_encoder = OneHotEncoder(handle_unknown=&#39;ignore&#39;, sparse=False)
  OH_cols_train = pd.DataFrame(OH_encoder.fit_transform(X_train[object_cols]))
  OH_cols_valid = pd.DataFrame(OH_encoder.transform(X_valid[object_cols]))
  
  # One-hot encoding removed index; put it back
  OH_cols_train.index = X_train.index
  OH_cols_valid.index = X_valid.index
  
  # Remove categorical columns (will replace with one-hot encoding)
  num_X_train = X_train.drop(object_cols, axis=1)
  num_X_valid = X_valid.drop(object_cols, axis=1)
  
  # Add one-hot encoded columns to numerical features
  OH_X_train = pd.concat([num_X_train, OH_cols_train], axis=1)
  OH_X_valid = pd.concat([num_X_valid, OH_cols_valid], axis=1)
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找字符串特征&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# get list of categorical variable
x = (df.dtypes == &#39;objects&#39;)
object_cols = x
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;标准化&#34;&gt;标准化&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Z-score 去均值、方差缩放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。&lt;/p&gt;

&lt;p&gt;尽量将数据转化为均值为零，方差为一的数据，形如标准正态分布（高斯分布）。实际中我们会忽略数据的分布情况，仅仅是通过改变均值来集中数据，然后将非连续特征除以他们的标准差：&lt;code&gt;(x-mean)/std&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;preprocessing.StandardScaler()&lt;/code&gt; 和&lt;code&gt;preprocessing.scale()&lt;/code&gt;都可以实现此目标，但standardScaler的好处是可以保存训练集中的参数（mean，std），直接使用其对象转换测试集数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;  scaler = preprocessing.StandardScaler().fit(train_data)
  train_scaled = scaler.transform(train_data)
  
  # 直接用scaler对象转换测试集数据
  test_scaled = scaler.trasform(test_data)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;缩放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;(x-min(axis=0))/(max(axis=0)-min(axis=0))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将特征属性缩放到一个指定的最大值和最小值（通常是 [0, 1]）之间，可以通过&lt;code&gt;preprocessing.MinMaxScaler&lt;/code&gt; 类实现。对于方差非常小的特征属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;  min_max_scaler = preprocessing.MinMaxScaler()
  tarin_x_minmax = min_max_scaler.fit_transform(tarin_x)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;正则化

&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;二值化&#34;&gt;二值化&lt;/h4&gt;

&lt;h4 id=&#34;哑编码&#34;&gt;哑编码&lt;/h4&gt;

&lt;h3 id=&#34;交叉验证&#34;&gt;交叉验证&lt;/h3&gt;

&lt;p&gt;在一个数据集中，势必要分出训练集和测试集，那么一盒中百分比分配就成了一个问题。因为一般来说，训练集越大模型越准确，但是相应的测试集就变小了，测试验证的时候可能不能够准确地验证模型的准确性高低。在这种情况下，可以采用交叉验证的返法，将数据集分为不同的子集，依次便利将一个子集作为测试集，其它子集作为训练集，验证模型的准确性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;from sklearn.model_selection import cross_val_score

# Multiply by -1 since sklearn calculates *negative* MAE
scores = cross_val_score(clf, X, y, cv=5,
                            scoring=&#39;neg_mean_absolute_error&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;clf指的是使用的算法&lt;/li&gt;
&lt;li&gt;cv是使用的交叉验证的生成器或迭代器，决定数据的划分，当cv为整数的时光，使用KFold方法&lt;/li&gt;
&lt;li&gt;Scoring 决定了使用的分数计算方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;决策树&#34;&gt;决策树&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;DecisionTreeRegressor&lt;/code&gt; 决策树，参数如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;max_leaf_nodes: int or None，最大叶子节点数，在特征分成过多的情况下通过定义它可以防止过拟合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;from sklearn.model_selection import train_test_split&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;train_test_split 函数旨在将矩阵随机划分为训练子集和测试子集两部分，并返回划分好的训练集、测试集样本和训练集、测试集标签：&lt;code&gt;x_train, x_test,y_tarin, y_test = train_test_split(train_data, train_target, trandom_state=0, test_size=0.3)&lt;/code&gt;    &lt;br&gt;random_state: 随机数编号，在需要重复测试的时候，通过此随机数编号得到一组一样的数据。    &lt;br&gt;train_size/test_size: 训练集/测试集样本占比，如果是整数则表示样本数量。&lt;/p&gt;

&lt;h3 id=&#34;随机森林&#34;&gt;随机森林&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python3&#34;&gt;from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error

forest_model = RandomForestRegressor(random_state=1)
forest_model.fit(train_X, train_y)
melb_preds = forest_model.predict(val_X)
print(mean_absolute_error(val_y, melb_preds))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;xgboost-极端梯度提升&#34;&gt;xgboost — 极端梯度提升&lt;/h3&gt;

&lt;p&gt;也是集成学习方法的一种，在大部分回归和分类问题上表现都很好。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.XGBRegressor&#34;&gt;XGBRegressor&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;优化调参&#34;&gt;优化调参&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;from sklearn.gird_search import RondomizedSearchCV,GridSearchCV
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pandas&#34;&gt;pandas&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;df.sort_values(by, axis=0, ascending=True, inplace=Flase, kind=&#39;quicksort&#39;, na_position=&#39;last&#39;)&lt;/code&gt; &lt;br&gt;axis=0时，by指的是列名；axis=1时，by指的是行名。&lt;br&gt;ascending默认为True，正序排列，也可传入bool的list对应by相同长度的list。&lt;br&gt;inplace默认false，是否使用排序后的数据代替原始数据。&lt;br&gt;kind指的是排序方法：quicksort, merge sort, heapsort.&lt;br&gt;na_position=&amp;lsquo;last&amp;rsquo; / &amp;lsquo;first&amp;rsquo; 指缺失值放在最后还是最前面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;df.nlargest(*n*, *columns*, *keep=&#39;first&#39;* )&lt;/code&gt;  &lt;br&gt;&lt;strong&gt;n&lt;/strong&gt; : int&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Number of items to retrieve&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;columns&lt;/strong&gt; : list or str&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Column name or names to order by&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;keep&lt;/strong&gt; : {‘first’, ‘last’, False}, default ‘first’&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Where there are duplicate values: - &lt;code&gt;first&lt;/code&gt; : take the first occurrence. - &lt;code&gt;last&lt;/code&gt; : take the last occurrence.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;df.values()&lt;/code&gt;  返回dataframe的numpy表示&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DataFrame.nunique(*self*, *axis=0*, *dropna=True)&lt;/code&gt; 返回列/行不重复元素的个数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pandas.get_dummies(*data*, *prefix=None*, *prefix_sep=&#39;_&#39;*, *dummy_na=False*, *columns=None*, *sparse=False*, *drop_first=False*, *dtype=None*)&lt;/code&gt; 将分类变量转换为指示变量，将一个分类变量变成多个1，0表示的变量&lt;/p&gt;

&lt;h2 id=&#34;scipy&#34;&gt;scipy&lt;/h2&gt;

&lt;h3 id=&#34;scipy-stats-包含了多种统计方法&#34;&gt;scipy.stats 包含了多种统计方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;norm&lt;/code&gt; 正太分布函数，norm.pdf(x) = $exp(-x**&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)/sqrt(2*pi)$&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python绘图</title>
      <link>https://charliemini.github.io/data/python%E7%BB%98%E5%9B%BE/</link>
      <pubDate>Thu, 11 Jul 2019 15:02:52 CST</pubDate>
      
      <guid>https://charliemini.github.io/data/python%E7%BB%98%E5%9B%BE/</guid>
      <description>&lt;h2 id=&#34;matplotlib&#34;&gt;matplotlib&lt;/h2&gt;

&lt;p&gt;在matplotlib种，整个图像为一个figure对象，而在这个figure对象中包含一个或多个axes对象，每个axes对象都是一个拥有自己坐标系的绘图区域。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fig,axes = plt.subplots(nrows, ncols)&lt;/code&gt; 接收行列数，返回一个figure对象和axes对象。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;axes.set_ylim&lt;/code&gt; 设置y轴区间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plt.plot&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plt.xticks(roartion=90)&lt;/code&gt; 图横坐标标注旋转90度&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plt.xlabel()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plt.ylabel()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Plt.title()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plt.figure(figsize=(6,6))&lt;/code&gt;定义长宽属性的画布&lt;/p&gt;

&lt;h2 id=&#34;seaborn&#34;&gt;seaborn&lt;/h2&gt;

&lt;h3 id=&#34;核密度估计&#34;&gt;核密度估计&lt;/h3&gt;

&lt;p&gt;核密度估计（KDE），也叫非参数估计方法，即对数据分布不添加任何假定条件，直接从数据样本本身研究数据分布特征。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;seaborn.kdeplot()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;seaborn.distlpot()&lt;/code&gt;集成了matplotlib的直方图方法hist() 与kdeplot 方法。&lt;/p&gt;

&lt;h3 id=&#34;调色板&#34;&gt;调色板&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.color_palette()&lt;/code&gt; 允许传入任何matplotlib制定有效的颜色数组，返回一个可供使用的RGB元祖列表。&lt;br&gt;&lt;code&gt;color_palette(&amp;quot;hls&amp;quot;, 8)&lt;/code&gt; 使用hls颜色区域定义8种颜色.  &lt;br&gt;&lt;code&gt;color_palette(&amp;quot;paired&amp;quot;, 8)&lt;/code&gt;  定义8种颜色，每两个一对，颜色相近。&lt;br&gt;&lt;code&gt;coloir_palette(&amp;quot;Blues&amp;quot;)&lt;/code&gt; 还可以传进来一个颜色名称，定义一个渐变色的调色板，默认是8个，渐变是由浅至深，要想变成有深至浅反过来在传参后面加上&lt;code&gt;_r&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;散点图&#34;&gt;散点图&lt;/h3&gt;

&lt;h3 id=&#34;热力图&#34;&gt;热力图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt=&#39;.2g&#39;, annot_kws=None, linewidths=0, linecolor=&#39;white&#39;, cbar=True, cbar_kws=None, cbar_ax=None, square=False, xticklabels=&#39;auto&#39;, yticklabels=&#39;auto&#39;, mask=None, ax=None, **kwargs)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重要的参数：data是数据源，可以是一个二维数组。&lt;/p&gt;

&lt;p&gt;​                        cannot = True 则展示单元格数字&lt;/p&gt;

&lt;p&gt;​                        cmap 是指色彩颜色的选择&lt;/p&gt;

&lt;h3 id=&#34;分类柱形图&#34;&gt;分类柱形图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.barplot(x=None, y=None, data=None)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;箱线图&#34;&gt;箱线图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.boxplot(x=None, y=None, data=None)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数data是数据集，x为x轴，y为y轴，如果data是dataframe，x轴和y轴可以是他的列名。&lt;/p&gt;

&lt;h3 id=&#34;结构化多绘图网格&#34;&gt;结构化多绘图网格&lt;/h3&gt;

&lt;p&gt;利用数据集上不同子集的数据在同一张图上绘制子集数据图。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;seaborn.FacetGrid(data=None, col=None, row=None, hue=None)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;data必须是合适的dataframe数据，col、row、hue都是定义数据自己的变量（列名），每一个都将在网格的不同位置绘制。&lt;/p&gt;

&lt;p&gt;但如果仅仅是调用该方法，只会初始化网格，并不会在它们上面绘制任何内容。想要在他身上可视化数据主要用FacetGrid.map()方法。&lt;/p&gt;

&lt;p&gt;map方法里要提供为其提供绘图功能的函数方法function，要绘制的数据变量名称args(df列名)，然后会将df那列数据按照调用指定变量的顺序传递给function，还可以通过kwargs传递关键字字典传递该function本身方法的参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g.map(function, *args, **kwargs)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;小提琴-图&#34;&gt;&amp;ldquo;小提琴&amp;rdquo;图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.violinplot(x, y, data, hue=None, split=True)&lt;/code&gt;  &lt;br&gt;当split为true的时候，画出的小提琴图沿中轴线分别表示hue参数指定的特征两种分类。&lt;/p&gt;

&lt;h3 id=&#34;联合绘图&#34;&gt;联合绘图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.jointplot(x, y, data, kind)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;jointplot方法一般用于两个变量之间的联合绘图，指定x和y的变量，data是数据源，kind参数则是制定绘图的格式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;kind = scatter （默认 ） 带边缘直方图的散点图&lt;/li&gt;
&lt;li&gt;kind = reg   带边缘核密度估计的回归图&lt;/li&gt;
&lt;li&gt;kind = hex 带边缘直方图的六边形区域图，在数据量大的情况下，可以通过六边形的深浅清晰观测数据的分布（叠合）。&lt;/li&gt;
&lt;li&gt;kind = kde kde图&lt;/li&gt;
&lt;li&gt;Residents&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;多变量图&#34;&gt;多变量图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.pariplot()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此函数将创建一个axes网格，使得传入的data参数重每个变量之间两两组合，形成n*n的对比图。&lt;/p&gt;

&lt;h3 id=&#34;回归图&#34;&gt;回归图&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;seaborn.regplot(data, x, y , x_jitter=.05, ...)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;x_jitter 指对x特征的编译量，新特征数据将会在定义范围的偏移量中进行随机的偏移抖动。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GO学习笔记</title>
      <link>https://charliemini.github.io/post/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 12 Jun 2019 20:54:36 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;结构化程序&#34;&gt;结构化程序&lt;/h2&gt;

&lt;p&gt;每个程序都由pkg的概念组成，必须在源代码里非注释的第一行致指明这个文件属于哪一个包,注意包的名字都要用小写字母。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package main&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;p&gt;重定义包名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import fm &amp;quot;fmt&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果导入了一个没有使用的包会报错&lt;/p&gt;

&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;

&lt;p&gt;结构化的类型以nil作为默认值&lt;/p&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;p&gt;用const定义，用于存储不会改变的数据线，只能是布尔型、数字和字符串。&lt;/p&gt;

&lt;p&gt;支持显、隐式类型定义&lt;/p&gt;

&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;

&lt;p&gt;用&lt;code&gt;var&lt;/code&gt;关键字声明变量 &lt;code&gt;var identifier type&lt;/code&gt; OR &lt;code&gt;var identifier type = value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当变量被声明后，系统自动赋予它该类型的零型，所有的内存在go中都是经过初始化的。变量命名规则遵循驼峰法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果希望全局变量被外部包使用，则需要将首个单词字母大写&lt;/strong&gt;*。&lt;/p&gt;

&lt;p&gt;在函数体内部初始化声明变量时可以使用简短的语法：&lt;code&gt;a := 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;声明局部变量而不去使用它同样会出现编译错误&lt;/p&gt;

&lt;p&gt;使用等于号进行变量间的相互赋值时，只是引用了同一个地址指针。&lt;/p&gt;

&lt;p&gt;如果想要交换两个文明变量的值，可以使用&lt;code&gt;a,b = b,a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_&lt;/code&gt; 被当作一个只写变量&lt;/p&gt;

&lt;p&gt;全局变量除了可以在全局声明中初始化，也可以在&lt;code&gt;init&lt;/code&gt;函数中初始化,也就是在声明的全局变量，可以经由&lt;code&gt;init&lt;/code&gt; 函数更改赋值并作用于整个程序作用域。&lt;/p&gt;

&lt;h2 id=&#34;基本类型与运算符&#34;&gt;基本类型与运算符&lt;/h2&gt;

&lt;p&gt;GO是强类型语言，只支持显示转换，所以只有类型严格相同时才可以做运算操作。&lt;/p&gt;

&lt;p&gt;不允许不同类型之间的混合使用，但允许和常量之间的混合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	var a int
	var b int 16
	a = 1
	b = a + a // 错误
	b = b + 5 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化字符串：%d用于格式化字符串&lt;/p&gt;

&lt;p&gt;​                           %x，%X用于格式化16进制表示的数字&lt;/p&gt;

&lt;p&gt;​                           %g用于格式化浮点数（%f输出浮点数，%e输出科学计数表示法）&lt;/p&gt;

&lt;p&gt;​                            %0d用于输出定长的整数&lt;/p&gt;

&lt;p&gt;​                           %n.mg用于表示数字n并精确到小数点后m位，g还可以替换为e，f&lt;/p&gt;

&lt;p&gt;在算数运算时溢出并不会产生错误，只会将超出的位数抛弃。对于产出范围的有理数可以使用标准库中的&lt;code&gt;big&lt;/code&gt;包&lt;/p&gt;

&lt;p&gt;为了简化名称和解决名称冲突，可以使用类型别名。&lt;code&gt;type A int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;GO字符串中字符为ASCII时占用一个字节，其它字符根据需要占据2-4个字节。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings&lt;/code&gt;包&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;strings.HasPrefix(s, string) bool 判断s是否以string开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.HasSuffix(s, string) bool 判断s是否以string结尾&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Contains(s, string) bool 判断字符串s是否包含string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Index(s, string) int 返回字符串string在s中第一个匹配的索引，返回-1表示不存在&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.LastIndex(s, string) int返回字符串string在s中最后一个匹配的索引，返回-1表示不存在&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于非ASCII编码的ch，建议使用strings,IndexRune定位                            strings.IndexRune(s, ch) int&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Replace(s, old, new, n) string 字符替换，n表示替换前几个字符，n=-1表示全替换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Count(s, string) int 计算string在s中出现的非重叠次数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.Repeat(s, count int) string 返回count次重复字符串s的的心字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.ToLower(s) string 转化为小写字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.ToUpper(s) string 转化大写字符&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strings.TrimSpace(s, &amp;ldquo;&amp;rdquo;) 剔除字符串s开头结尾指定字符&lt;/p&gt;

&lt;p&gt;strings.TrimLeft()&lt;/p&gt;

&lt;p&gt;strings.TrimRight()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string.Fields(s, sep) 切割字符串，返回slice&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string.Join(sl []string, sep string) string 将字符串数组用字符sep拼接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String.NewReader(str) 用于生成一个reader并读取字符串中的内容，并返回指向该reader的指针。&lt;/p&gt;

&lt;p&gt;Read() —&amp;gt; byte&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;strconv&lt;/code&gt;包&lt;/p&gt;

&lt;p&gt;用于字符串相关的类型转换。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strconv.Atoi(s string) (i int, err error)&lt;/code&gt; 将字符串转换为 int 型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strconv.IntSize&lt;/code&gt; 获取程序运行的操作系统下int所占位数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;包，互斥锁。&lt;/p&gt;

&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;

&lt;p&gt;无法得到常量的地址&lt;/p&gt;

&lt;p&gt;对于一个空指针的反向引用是不合法的&lt;/p&gt;

&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;不要同时在if-else结构的两个分支里都使用return语句，会导致程序编译错误。(GO1.1 已修复)&lt;/p&gt;

&lt;p&gt;Runtime.GOOS 是常量，是程序运行的操作系统类型。&lt;/p&gt;

&lt;p&gt;if 可以包含初始化语句&lt;code&gt;if a := 10; a &amp;gt; number&lt;/code&gt; 这种方式定义的变量a只存在于if语句的作用域中。&lt;/p&gt;

&lt;p&gt;switch中，如果在命中case后还希望执行下面的case，可以使用&lt;code&gt;fallthrough&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;Go里的for循环和C一样，但存在一个for-range结构，可以迭代任何一个集合.     &lt;code&gt;for pos,char := range str&lt;/code&gt;  pos为索引位置，char为值。&lt;/p&gt;

&lt;p&gt;For,    switch,     select语句都可以配合标签使用。&lt;/p&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;p&gt;用&lt;code&gt;func&lt;/code&gt;定义函数，函数体用{}括起来&lt;/p&gt;

&lt;p&gt;main函数没有参数，也没有返回类型&lt;/p&gt;

&lt;p&gt;Go不允许进行函数重载，函数可以以声明的方式被使用，不需要函数体。&lt;/p&gt;

&lt;p&gt;返回多个非命名返回值时，需要在函数头事先用（）括起返回类型，尽量不要使用非命名返回值。&lt;/p&gt;

&lt;p&gt;在go中存在变参函数，类似于python中的*args，在传参中使用&lt;code&gt;name ...type&lt;/code&gt;的形式，可以传递多个同类型的参数形式。如果不确定变长参数的类型或者变长参数存在多种类型的时候，可以用默认的空接口&lt;code&gt;interface{}&lt;/code&gt;代替type。&lt;/p&gt;

&lt;p&gt;Go允许自己定义结构类型,其中可以混合多种变量类型.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type struct_name struct{
	part1 int,
	part float,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字defer在函数中被使用的时候，会在程序将要返回时执行，它类似栈，如果有多个defer会从最后面的开始执行。它允许我们进行一些&amp;rdquo;收尾&amp;rdquo;工作，比如关闭文件流，打印，解锁，关闭数据库，实现代码追踪。&lt;/p&gt;

&lt;p&gt;在大量的递归调用中可能会发生栈溢出的问题，也就是栈资源耗尽。&lt;/p&gt;

&lt;p&gt;匿名函数无法单独存在，但可以赋值给一个变量，func 关键字必须紧贴着第一个括号。这类似闭包，闭包可以看作是函数与外部变量的组合体，外部变量和函数一直存在。闭包避免了使用全局变量，将数据与函数紧密结合。&lt;/p&gt;

&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;var identifier [len]type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当数组还未定义时，可以使用make方法定义切片&lt;code&gt;var slice1 []type = make([]type, len)&lt;/code&gt;  简写为&lt;code&gt;slice1 := make([]type, len)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;[]byte&lt;/code&gt;进行切片要使用bytes包，&lt;code&gt;var buffer bytes.Buffer&lt;/code&gt;                       &lt;code&gt;var r *bytes.Buffer = new(bytes.Buffer)&lt;/code&gt; 利用buffer.WriteString(s)的方法拼接内容比使用 &lt;code&gt;+=&lt;/code&gt; 更省内存和cpu。&lt;/p&gt;

&lt;p&gt;遍历数组和切片可以使用 for-range 结构，返回数组索引和value。&lt;/p&gt;

&lt;p&gt;append方法可以实现对切片元素的增加，切片的拼接。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;map&lt;/h2&gt;

&lt;p&gt;map对应的数据结构时字典。声明&lt;code&gt;var mapname map[keytype]valuetype&lt;/code&gt;                          初始化 &lt;code&gt;map1 := make(map[keytype]valuetype)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;map传递给函数的代价很小，因为是用key传递的，而key在32位机器上占32个字节，在64位机器上占8个字节。map不要用new方法去声明，因为new方法如果错误使用的话，会创建一个空饮用的指针，所以最好一直用make创建map。map容量可以定义，超过容量会自动增加对应空间。&lt;/p&gt;

&lt;h2 id=&#34;自定义包&#34;&gt;自定义包&lt;/h2&gt;

&lt;p&gt;import格式： import &amp;ldquo;包的路径/url地址&amp;rdquo;&lt;/p&gt;

&lt;p&gt;主程序要利用的包必须要在主程序编译之前被编译完成。当时用&lt;code&gt;.&lt;/code&gt;来做倒入包的别名时，可以不通过包名来使用其中的项目，否则都要使用&lt;code&gt;packgename.function&lt;/code&gt;的形式来使用。可以使用&lt;code&gt;go install packagename&lt;/code&gt;的命令将洗定义的包编译安装到本地环境。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据相关性</title>
      <link>https://charliemini.github.io/post/%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E6%80%A7/</link>
      <pubDate>Tue, 08 Jan 2019 21:16:28 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E6%80%A7/</guid>
      <description>

&lt;h1 id=&#34;数据相关性&#34;&gt;数据相关性&lt;/h1&gt;

&lt;p&gt;做利用python的pandas做数据分析时 ，经常会用到&lt;code&gt;corr&lt;/code&gt;这个函数来得到数据相关系数，而这个函数可以使用3种普遍的数据统计方法，分别是：皮尔森（pearson）相关系数和斯皮尔曼（spearman）相关系数和肯德尔（kendall）相关系数。&lt;/p&gt;

&lt;h2 id=&#34;pearson&#34;&gt;pearson&lt;/h2&gt;

&lt;p&gt;定义：使用多维数据的协方差除以他们各自标准差的乘积得到相关系数。&lt;/p&gt;

&lt;p&gt;使用情况：在线性相关、正态分布的情况下使用精准度高。&lt;/p&gt;

&lt;p&gt;先从协方差说起，我们都知道标准差是用来统计一组数据的离散程度，方差是标准差的平方，或者说是“标准差的特殊情况”。而协方差可以看作是多维数据之间的“方差”，然后除以多维数据的“标准差”来得到相关离散系数。&lt;/p&gt;

&lt;h2 id=&#34;spearman&#34;&gt;spearman&lt;/h2&gt;

&lt;p&gt;定义:  &lt;img src=&#34;https://charliemini.github.io/Users/chenzhenxing/Documents/study_notes/dataAnalyse_study/spearman%E5%85%AC%E5%BC%8F.jpg&#34; alt=&#34;公式&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql主从复制</title>
      <link>https://charliemini.github.io/post/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Wed, 03 Oct 2018 19:36:49 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;

&lt;p&gt;mysql 支持以binglog日志的形式支持主从数据库同步备份。在5.7版本之前，会以一个io线程读取binlog日志，一个sql线程执行主库sql的形式执行。在5.7之后，mysql支持多线程备份，有两种模式，一种是一个库一个线程，另一种是一个库多个线程，但要支持这种多线程备份，数据表结构必须升级成5.7版本的。&lt;/p&gt;

&lt;p&gt;##环境&lt;/p&gt;

&lt;p&gt;数据库版本：5.1.73
系统版本：Centos 6.5&lt;/p&gt;

&lt;p&gt;##实现步骤
(1) 配置主库参数
&lt;code&gt;vim  /etc/my.cnf&lt;/code&gt;
在文件的[mysqld]标题下加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server-id = 1            #id要唯一 
log-bin = mysql-bin      #开启binlog日志
relay_log_purge=1
#binlog-do-db=IP_data     #需要同步的数据库名，如果有多个数据库，可重复此参数，每个数据库一行
#binlog-ignore-db=mysql   #忽略同步的数据库
#上述两项可能使主从数据库存在失误，建议全纪录日志,而在从库设置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启数据库
&lt;code&gt;service mysqld restart&lt;/code&gt;
(2)主库创建同步账号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&amp;gt;&#34;&gt;(3)配置从库参数
`vim  /et/my.cnf`
在文件的[mysqld]标题下加入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server-id = 3                           #这个设置大于1，且不能于其它从库相同
log-bin = mysql-bin                     #开启binlog日志
#replicate-do-db= IP_data               #备份数据库名
#replicate-ignore-db=mysql              #忽略备份的数据库名
replicate-wild-do-table = database.%    #设置备份数据库里所有表，更稳定
replicate-wild-ignore-table = mysql.%
read_only=1                         #设置只读&lt;br /&gt;
auto-increment-increment = 1        #这两个参数在Ubuntu系统中MySQL5.5以后都已经默认是1
auto-increment-offset = 1          #避免两台服务器同时做更新时自增长字段的值之间发生冲突
slave-skip-errors = all     #跳过主从复制出现的错误
log_slave_updates = 1     #开启从库的binlog日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(4)备份主库
方法一
`mysqldump -uroot -pxxxx --rutineso --skip-lock-tables --single-transaction --flush-logs --hex-blob --master-data=2 --database dbname &amp;gt; db.sql`

参数说明：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;–routines：导出存储过程和函数
–skip-lock-tables：不锁表
–single_transaction：导出开始时设置事务隔离状态，并使用一致性快照开始事务。
–master-data：默认等于1，将dump起始(change master to)binlog点和pos值写到结果中，等于2是将change master to写到结果中并注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;方法二
` mysqldump -h IP -uusername -pxxxxx -B db1 db2 db3 ....   -e --max_allowed_packet=4194304 --net_buffer_length=16384 --skip-lock-tables --single-transaction --flush-logs --hex-blob --master-data=2 &amp;gt;backup.sql`

(5)将sql文件导入从库
`create database dbname`
`mysql -uroot -pxxx dbname&amp;lt;db.sql`

如果导入途中出现`Repair by sorting`太慢的问题，可能是某个表太大了，默认的磁盘空间不够。需要事先设置配置文件：
`myisam_max_sort_file_size=xxG`     这个值根据需求设置 

(6)从库设置从musqldump的时间点导入日志
可以通过下面这个命令查看
`show master STATUS`
得到： ![1539312278(1).png](https://upload-images.jianshu.io/upload_images/7954818-24c3c33edea0b0af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
然后在从库执行：
` change master to master_host=&#39;IP&#39;, master_user=&#39;mysqlcopy&#39;, master_password=&#39;XXX&#39;,  master_port=3306，master_log_file=&#39;mysql-bin.000009&#39;, master_log_pos=106;
`
从库开启同步：
`start slave;`
执行`show slave status\G;`
看到
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Slave_IO_Running: Yes
Slave_SQL_Running: Yes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;就代表初步成功了
##遇到的问题
执行第六步的时候，发现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Slave_IO_Running: NO
Last_IO_Error: Got fatal error 1236 from master when reading data from binar&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;解决方法：
先关闭同步：`stop slave;`
然后刷新日志：`flush logs;`
日志后缀会加1，最后从库重新同步新日志
` change master to master_host=&#39;IP&#39;, master_user=&#39;mysqlcopy&#39;, master_password=&#39;XXX&#39;,  master_log_file=&#39;mysql-bin.000010&#39;, master_log_pos=106;
`
开启同步：`start slave;`
问题得以解决
## 附

（1）清理除了正在使用的其他日志文件  `purge binary logs to &#39;mysql-tb-bin.000005&#39;;`

（2）清理预设日期之前的日志 `expire_logs_days=15（天数）`

（3）设置日志文件最大容量 ` max_binlog_size = 1G`

###安装5.1.73
centos：去官网下载rpm包
               同级目录下`yum install xx`
###安装5.7
将源更新安装
### 配置

更改文件
centos：`/etc/my.cnf`
ubuntu:`/etc/mysql/mysql.conf.d/mysqld.cnf`
`cp \var\lib\mysql 新路径`
记得赋予权限
关闭mysql修稿配置

###mysql5.1.73
更改存储位置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[client]
#socket         = /var/lib/mysql/mysql.sock
default-character-set=utf8
socket=******  #新的安装路径+mysql.sock&lt;/p&gt;

&lt;p&gt;[mysqld]
#socket         = /var/lib/mysql/mysql.sock
datadir= ****** #新的安装路径
socket= ******&lt;/p&gt;

&lt;p&gt;[mysql]
default-character-set = utf8
socket=******&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;###mysql5.7
修改`/etc/mysql/mysql.conf.d/mysqld.cnf`
`datadir= ****** #新的安装路径`
修改`/etc/apparmor.d/usr.sbin.mysqld`
将以下路径修改
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;allow-data-dir-access&#34;&gt;Allow data dir access&lt;/h1&gt;

&lt;p&gt;/var/lib/mysql r,
  /var/lib/mysql/** rwk,
``&lt;code&gt;
然后&lt;/code&gt;/etc/init.d/apparmor  restart`&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何判断http链接文件日期</title>
      <link>https://charliemini.github.io/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADhttp%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%E6%97%A5%E6%9C%9F/</link>
      <pubDate>Wed, 14 Feb 2018 16:30:31 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADhttp%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%E6%97%A5%E6%9C%9F/</guid>
      <description>&lt;p&gt;##last-modified
请求响应头里的参数（利用requests获取到的HEAD可以看作是字典），记录最近一次文件修改时间。&lt;/p&gt;

&lt;p&gt;##ETag 实体标签
HTTP1.1中加入的属性，用来帮助服务器控制Web端的缓存验证。&lt;/p&gt;

&lt;p&gt;原理：当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值并通过 ETag 返回给浏览器，浏览器把这个哈希值 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: &amp;ldquo;3f80f-1b6-3e1cb03b&amp;rdquo; 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全量数据返回给客户端。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>学习记录</title>
      <link>https://charliemini.github.io/post/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</link>
      <pubDate>Mon, 12 Feb 2018 22:25:38 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</guid>
      <description>&lt;p&gt;#临界区
临界区是一段代码，保证在多线程或其他情况下只能被一个线程执行，可以用信号量或互斥量来保护临界区。&lt;/p&gt;

&lt;p&gt;#堆和栈
CPython为例，所有变量都是一个PyObject*，也就是指针，而所有赋值语句都是将一个对象的地址赋值给它，其实不光是变量，容器里面的也是，比如list和dict的元素等。
&lt;code&gt;id([object])&lt;/code&gt; 返回对象的内存地址&lt;/p&gt;

&lt;p&gt;栈(Stack)是运行时的单位，而堆(Heap)是存储的单位。
栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；
堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
#强类型程序设计语言
强类型的的语言就是编译器能够保证正确性，例如在C和Java中你无法在字符类型中放入数字，你只能将兼容的值存入相应的类型中。反之就是Python这样的弱类型程序设计语言，不要求在编译时进行类型检查，它们根据上下文处理值。
#SQL注入
一种安全漏洞，从用户哪里得到输入但不加查证去创建SQL查询的系统可能存在这种风险。
#疏耦合
软件设计追求的一个特性，就是指软件各模块影响程度低，修改了这个部分不会影响到另一个部分。
#二叉查找树
对于一个节点，它的左子树上所有的节点的值都小于或等于它的值，它的右子树上所有节点的的值都大于或等于它的值。&lt;/p&gt;

&lt;h1 id=&#34;python-进程&#34;&gt;python 进程&lt;/h1&gt;

&lt;p&gt;python多进程用multiprocessing模块
multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。&lt;/p&gt;

&lt;p&gt;假设你使用的是multiprocessing的Pool，是使用多进程实现了concurrency
from multiprocessing import Pool
如果把这个代码改成下面这样，就变成多线程实现concurrency
from multiprocessing.dummy import Pool
两种方式都跑一下，哪个速度快用哪个就行了。&lt;/p&gt;

&lt;p&gt;Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。
1.设置GIL。
2.切换到一个线程去执行。
3.运行。
4.把线程设置为睡眠状态。
5.解锁GIL。
6.再次重复以上步骤。&lt;/p&gt;

&lt;p&gt;对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。&lt;/p&gt;

&lt;p&gt;#is 和 == 的区别
在python中对象基本包含了以下三个要素：id()（身份标识&amp;ndash;地址）、type(),value()。
is比较的是id，而==比较的是value值。&lt;/p&gt;

&lt;p&gt;在python中，定义了 [-5,256) 的整数是早已被定义在了内存池中，当引用这些对象时直接引用它们在内存池中的地址，所以id相同。而float类型并没有保存在内存池中，所以id都不相同。&lt;/p&gt;

&lt;p&gt;字符串类型是因为python中有一个intern机制，将已经创建的字符串（驻留机制的字符，即不包含特殊字符）以键值对的形式（地址为值）放进一个字典中，如果在创建一个字符变量，先在这个字典中查找，如果有相同的，直接将他的地址引用。&lt;/p&gt;

&lt;p&gt;#为什么python中没有重载
重载是为了什么：
&lt;strong&gt;1.改变参数类型&lt;/strong&gt;
&lt;strong&gt;2.改变参数个数&lt;/strong&gt;
对于第一个目的，python可以接受任何类型的参数，不存在问题
对于第二个目的，python可以使用缺省参数（缺省参数即是调用该函数时，缺省参数的值若未被传入，则传入默认预设的值）
所以python也就不需要重载了&lt;/p&gt;

&lt;p&gt;#单例模式
保证系统中的一个类只有一个实例且易于外界访问，方便控制实例个数和节约资源。
&lt;strong&gt;python中模块就是天然的单例模式&lt;/strong&gt;
当第一次导入一个模块时，会创建一个.pyc文件，之后再次导入直接加载这个.pyc文件，而不会去执行该模块代码。所以只需把相应的函数和变量放到一个模块中，就能产生一个单例对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#single.py
class singlemoudle(object):
    def func(self):
        pass

mysingle = singlemoudle()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#main.py
from single import mysingle

mysingle.func()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用&lt;strong&gt;new()&lt;/strong&gt;方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class singlemoudle(object):
    _isexist = None
    def __new__(cls, *args, **kwards):
        if not _isexist:
            cls._isexist = super(singlemoudle, cls).__new__(cls, *args, *kwards)
        return cls._isexist
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Git学习</title>
      <link>https://charliemini.github.io/post/git%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 03 Jan 2018 22:23:22 CST</pubDate>
      
      <guid>https://charliemini.github.io/post/git%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;h1 id=&#34;git的学习笔记&#34;&gt;GIT的学习笔记&lt;/h1&gt;

&lt;p&gt;这是我初学GIT时记录下的笔记，很多地方都记录的不详细（毕竟我只是怕忘记了又要去查才简要记录了一点），并不足以参考，若想学习Git，请移步到下面网址：&lt;/p&gt;

&lt;p&gt;浅显易懂完整的GIT学习教程在这里&lt;br /&gt;
&lt;a href=&#34;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;廖雪峰的官方网站-Git教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#Git的概念
简单来说，Git的工作流程很简单，我们把整个过程中文件的转移分为3个区域：工作区，暂存区，分支。&lt;/p&gt;

&lt;p&gt;工作区就是我们对文件进行操作的地方，比如你在本地GIt仓库修改文件，编写代码的文件存储空间。现在你的文件改好了，想把它提交到Git仓库中，先要把它提交到暂存区，最后再提交到分支。默认的分支为master，也可以自己创建分支。这样文件就被保存到Git仓库里了。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/7954818-265ebaec16940816?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;本地git仓库&#34;&gt;本地Git仓库&lt;/h2&gt;

&lt;p&gt;进入一个文件夹， &lt;code&gt;git init&lt;/code&gt; 新建一个git仓库a&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git add &amp;lt;filename&amp;gt;&lt;/code&gt; 将文件添加到到暂存区&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git commit -m &#39;xxx&#39;&lt;/code&gt; 将文件提交到分支，参数-m后面写上对本次提交的说明，最好写上&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 显示仓库当前状态&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 查看各版本文件的不同，显示的格式为Unix通用的diff格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 显示时间最近到最远的提交版本的详细信息，加上参数 &lt;code&gt;--pretty-- oneline&lt;/code&gt; 显示简要信息，其中有版本号&lt;/p&gt;

&lt;p&gt;在Git中，&lt;code&gt;HEAD&lt;/code&gt; 表示当前版本，上一版本为 &lt;code&gt;HEAD^&lt;/code&gt;，上上一版本为 &lt;code&gt;HEAD^&lt;/code&gt; 或 &lt;code&gt;HEAD~2
&lt;/code&gt;，以此类推。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reset --hard HEAD&lt;/code&gt; 将文件重置为上一个版本，也可通过版本好重置： &lt;code&gt;git reset --hard 版本号&lt;/code&gt; 版本号只需打出足够辨识的前几位&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reflog&lt;/code&gt; 显示出每一历史命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git diff HEAD -- &amp;lt;filename&amp;gt;&lt;/code&gt; 查看最新版本库与工作区文件的区别&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git checkout -- &amp;lt;filename&amp;gt;&lt;/code&gt; 撤销文件在工作区的修改（尚未提交到分支）回到最近一次&lt;code&gt;add&lt;/code&gt;或&lt;code&gt;commit&lt;/code&gt;是的状态&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reset Head &amp;lt;filename&amp;gt;&lt;/code&gt; 撤销暂存区修改，放回工作区&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rm &amp;lt;filename&amp;gt;&lt;/code&gt; 从版本中删除文件，要&lt;code&gt;commit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;##连接远程库
我这里以Github为例&lt;/p&gt;

&lt;p&gt;创建SSH key（本地库与远程库关联的密钥）&lt;/p&gt;

&lt;p&gt;在shell中输入&lt;code&gt;ssh-keygen -t rsa -C &#39;youremail@example.com&#39;&lt;/code&gt;,再在github用户功能下，添加进去密钥，建议添加id+rsa.pub的内容&lt;/p&gt;

&lt;p&gt;关联github上的git仓库，先创建一个仓库，然后在本地仓库执行命令：
    &lt;code&gt;git remote add origin git@github.com:&amp;lt;github账户&amp;gt;/&amp;lt;仓库名&amp;gt;.git&lt;/code&gt; 这样就关联成功了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;  把本地库的master推送到github的远程库上，第一次推送加上参数-u，还会把本地的maste分支和远程的master分支关联起来，以后就可以只用 &lt;code&gt;git push origin master&lt;/code&gt; 推送就行了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone git@github.com:&amp;lt;github账户&amp;gt;/&amp;lt;远程库名&amp;gt;.git&lt;/code&gt;    将远程库克隆到本地&lt;/p&gt;

&lt;p&gt;##分支
分支让我们跟方便的管理项目，比如一个项目正式的发布版本在master分支上，那我们不可能在master上直接改，出差错了怎么办。一般都会创建一个新分支，比如分支branch1，作为项目发布前的主分支。项目组的工作人员在没人创建一个分支Mybranch，以branch1为模板，各自写自己负责的代码，在合并到branch1上，测试通过后，再把branch1合并到master上。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git checkout -b &amp;lt;分支名&amp;gt;&lt;/code&gt;  创建并切换分支，相当于两条命令：&lt;code&gt;git branch xx&lt;/code&gt; ;&lt;code&gt;git checkout xxx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;  查看当前所有分支 ，*会出现在当前所在分支前&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git merge xx&lt;/code&gt;  将xx分支合并到当前分支上（这样会采用Fast forward 模式，这种模式删除分支后会丢掉分支信息）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git merge --no-ff -m &#39;xxx&#39; 分支名&lt;/code&gt;   用&amp;ndash;no-ff 参数禁用fast froward&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git branch -d xx&lt;/code&gt;  删除xx分支   若加上参数&lt;code&gt;-D&lt;/code&gt;表示强行删除&lt;/p&gt;

&lt;p&gt;如果master和别的分支都分别有新的提交，git无法快速合并，只能试图将各自的修改合并起来，但可能会引起冲突，必须手动解决冲突再提交。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git log --graph&lt;/code&gt;  显示分支合并图&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git stash&lt;/code&gt;  保存当前未提交的改动。如果你得为你的项目新加一个功能，在你的分支上代码写了一半了，结果项目中发现了一个bug,你必须马上解决。可你又无法提交你现在改动的项目（因为还未完成），这个时候你可已选择保存它，回到未改动前的版本，解决了bug再回来继续写完它。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git satsh list&lt;/code&gt;  显示保存的工作现场&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git satsh apply&lt;/code&gt;  恢复，但是恢复后stash内容并不删除，需要用&lt;code&gt;git satsh drop&lt;/code&gt;来删除&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git satsh pop&lt;/code&gt; 恢复工作现场的同时把stash的内容也删除了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote -v&lt;/code&gt;查看远程库信息，参数&lt;code&gt;-V&lt;/code&gt; 显示更详细的信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git checkout -b dev origin/dev&lt;/code&gt; 创建远程的dev分支到本地&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; 得到当前分支的最新提交&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;git pull&lt;/code&gt;提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令&lt;code&gt;git branch --set-upstream branch-name origin/branch-name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;##标签
Git的标签虽然是版本库的快照，但其实它就是指向某个&lt;code&gt;commit&lt;/code&gt;的指针，方便人们查找&lt;/p&gt;

&lt;p&gt;切换到需要打标签的分支上，&lt;code&gt;git tag &amp;lt;branch-name&amp;gt;&lt;/code&gt;打上标签，like:&lt;code&gt;git tag v1m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;默认标签打在最新提交的&lt;code&gt;commit&lt;/code&gt;上，若想打在之前的&lt;code&gt;commit&lt;/code&gt;上，就要找到那个&lt;code&gt;commit&lt;/code&gt;的id，然后
&lt;code&gt;git tag  &amp;lt;tagname&amp;gt; &amp;lt;commit id&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git tag&lt;/code&gt; 查看所有标签 标签按字母顺序排序，而非创立的时间顺序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git show &amp;lt;tagname&amp;gt;&lt;/code&gt; 查看某一标签的具体信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git tag -a &amp;lt;tagname&amp;gt; -m &#39;xx&#39;&lt;/code&gt; 创建带说明的标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git tag -d &amp;lt;tagname&amp;gt;&lt;/code&gt; 删除（本地）标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push origin &amp;lt;tagname&amp;gt;&lt;/code&gt;  推送某个标签到远程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push origin --tags&lt;/code&gt; 推送全部尚未推送到远程的本地标签&lt;/p&gt;

&lt;p&gt;若要删除已推送到远程的标签，先删除本地标签，再删除远程标签，删除远程库上的标签：
&lt;code&gt;git push origin :refs/tags/&amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;##注意事项
&lt;code&gt;git rm --cache submodule_name&lt;/code&gt; 删除子模组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git branch --set-upstream-to=origin/dev dev&lt;/code&gt;  关联远程分支&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
